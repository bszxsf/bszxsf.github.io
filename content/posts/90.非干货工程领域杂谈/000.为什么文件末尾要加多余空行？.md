---
published: 2025-03-17T13:55:00+0800
---

# 为什么文件末尾要加多余空行？

我相信不止我自己问过标题中的这个问题。不难注意到，许多开源项目中，所有文件末尾都会多一个额外的空行，它看起来没什么用，那么添加它的意义是什么？

## 防止git冲突，减少git变更

我最早在git信息中注意到这一点，如果提交的文件末尾没有多余空行，git很有可能打印一行警告。后来我需要维护一个软件项目，其中有一个文件是会被代码生成器处理的列表，并且列表内容会随着功能增加而增多。这里我注意到了第一个好处：git diff是以行为单位的，而“行”的概念包括了其末尾的换行符；如果末尾没有多余空行，加入新列表项（新行）后原本的最后一行就会多出一个换行符。原本只是增加行的操作，却因为缺少多余空行导致了删减；这极大地提升了多人协作git开发时出现合入冲突的可能性。

## 避免第三方工具引发非预期结果，简化工具使用逻辑

许多早期工具在拼接文件（类似C的`#include`行为）时并不会添加换行符，这会在许多场景导致bug；这时肯定有人回想，直接添加换行符就好了，然而问题没有那么简单：你怎么知道用户真的想要换行符呢？

Linux并不真正区分二进制文件和文本文件，它不在乎字符编码，一切编码问题交给应用程序处理。如果用户想要拼接的其实是两个二进制串而不是字符串，擅自添加换行符就成了画蛇添足。举例而言，假设我们有a和b两个文件，文件内容都是通过C语言`fwrite`写入的二进制结构体的数组，每个结构体都是定长的（也即，不含灵活数组成员flexible array member，有时简称fam）。而读取的程序也很简单：通过`fread`持续读取大小相当于该结构体大小的字节块，并直接送进结构体，一直读取到文件末尾。对于分别处理a和b，读取显然是不会出问题的；对于简单合并a和b的内容再读取，也不会出问题；然而如果拼接程序擅自加一个换行符的话，b文件的开头就会凭空多出一个换行符，导致后面所有结构体的内容出错，并且还会多出一个字节。

这里我们还需要提醒读者：Linux的哲学是一个应用专注于一件事，拼接程序就只专注于拼接。由于Linux不会真正关心文件编码，让拼接程序识别其内容是否需要添加换行符也是不可能做到的，一个二进制文件的内容也完全可以恰好完全由[1, 127]区间上的值和末尾的0构成。除非是公认的、大家都尊重的文件格式（可以通过一些二进制文件特征来识别，例如文件开头的魔数，其本质仍然是预先知道这个文件是做什么用的），否则通过文件内容推测其用途和格式是完全不存在可行性的。

因此，即便在今天，为文本文件末尾多加一行空行也能极大地减少配合第三方工具使用时出现问题的概率。
